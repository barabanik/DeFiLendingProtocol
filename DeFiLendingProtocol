// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract DeFiLendingProtocol is Ownable {
    // ERC20 token used as collateral
    IERC20 public collateralToken;

    // Mapping from user address to their collateral balance
    mapping(address => uint256) public collateralBalances;

    // Mapping from user address to their borrow balances
    mapping(address => uint256) public borrowBalances;

    // Events
    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Borrow(address indexed user, uint256 amount);
    event Repay(address indexed user, uint256 amount);

    constructor(address _collateralToken) {
        collateralToken = IERC20(_collateralToken);
    }

    // Deposit collateral
    function deposit(uint256 amount) external {
        require(amount > 0, "Deposit amount must be greater than zero");

        // Transfer collateral tokens from user to this contract
        require(collateralToken.transferFrom(msg.sender, address(this), amount), "Transfer failed");

        // Increase user's collateral balance
        collateralBalances[msg.sender] += amount;

        emit Deposit(msg.sender, amount);
    }

    // Withdraw collateral
    function withdraw(uint256 amount) external {
        require(amount > 0 && amount <= collateralBalances[msg.sender], "Invalid amount");

        // Decrease user's collateral balance
        collateralBalances[msg.sender] -= amount;

        // Transfer collateral tokens from this contract to user
        require(collateralToken.transfer(msg.sender, amount), "Transfer failed");

        emit Withdraw(msg.sender, amount);
    }

    // Borrow tokens against collateral
    function borrow(uint256 amount) external {
        require(amount > 0 && amount <= availableBorrowLimit(msg.sender), "Invalid amount");

        // Increase user's borrow balance
        borrowBalances[msg.sender] += amount;

        // Transfer borrowed tokens from this contract to user
        // In a real implementation, you would transfer a specific token (not implemented here)
        emit Borrow(msg.sender, amount);
    }

    // Repay borrowed tokens
    function repay(uint256 amount) external {
        require(amount > 0 && amount <= borrowBalances[msg.sender], "Invalid amount");

        // Decrease user's borrow balance
        borrowBalances[msg.sender] -= amount;

        // Transfer tokens from user to this contract as repayment
        // In a real implementation, you would transfer a specific token (not implemented here)
        emit Repay(msg.sender, amount);
    }

    // Calculate available borrow limit based on collateral
    function availableBorrowLimit(address user) public view returns (uint256) {
        // In a real implementation, you would calculate based on collateral value and LTV ratio
        return collateralBalances[user] / 2; // Simplified example: LTV ratio of 50%
    }
}
